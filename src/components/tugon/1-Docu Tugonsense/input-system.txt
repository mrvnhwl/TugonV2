TUGON INPUT SYSTEM - Multi-Line Mathematical Step-by-Step Input Documentation
===============================================================================

OVERVIEW
--------
This system provides an intelligent multi-line text input interface for educational 
applications, specifically designed for mathematical problem-solving with step-by-step 
answer collection, two-phase validation, progressive percentage scoring, and smart 
position-aware feedback.

KEY FEATURES
------------
âœ… Two-Phase Validation (Mathematical Equivalence + Positional Validation)
âœ… Progressive Percentage Scoring (20% â†’ 80% â†’ 100%)
âœ… Smart Final Answer Detection with Position Enforcement  
âœ… Auto-Scrolling Multi-Line Input with Line Restrictions
âœ… Real-Time Step-by-Step Progress Indicators
âœ… Anti-Spam Protection and Focus Management
âœ… Label-Based Step Context Awareness

FILE STRUCTURE & RESPONSIBILITIES
---------------------------------

1. answers.ts
   - Central database of predefined correct answers with step labels
   - NEW: Step-based structure with labels: "substitution", "simplification", "final", "math", "text"
   - Each answer stored as Step[] array with {label, answer} objects
   - Organized by Topic â†’ Category â†’ Questions structure
   - Example: steps: [
       { label: "substitution", answer: "6(6)+4" },
       { label: "simplification", answer: "36 + 4" }, 
       { label: "final", answer: "40" }
     ]

2. AnswerInput.tsx (Deprecated - replaced by native inputs)
   - Legacy component - no longer used in current system

3. UserInput.tsx (HEAVILY UPDATED)
   - Advanced multi-line input manager with intelligent features
   - NEW: Two-phase validation system (mathematical + positional)
   - NEW: Progressive percentage scoring system
   - NEW: Smart line restriction based on expected steps count
   - NEW: Auto-scrolling when exceeding 2 visible lines
   - NEW: Enhanced focus management with aggressive retry logic  
   - NEW: Real-time progress bar with color-coded feedback
   - NEW: Final answer detection with position enforcement rules
   - Manages dynamic line creation restricted to expected steps count

4. UserInputValidator.tsx (COMPLETELY REWRITTEN)
   - NEW: Two-phase validation architecture
   - NEW: Smart step validation with cross-contamination prevention
   - NEW: Mathematical equivalence checking with positional awareness
   - NEW: Final answer jump detection across all input positions
   - Preserves mathematical flexibility while enforcing step order
   - Enhanced logging with step label context and validation phases

5. AnswerWizard.tsx (SIMPLIFIED)
   - High-level orchestrator component (simplified from complex logic)
   - Removed toast notifications, hints, and guidance systems
   - Now focuses purely on input coordination and submission
   - Uses UserInput component for all validation and progression logic

DATA FLOW & TWO-PHASE VALIDATION ARCHITECTURE
---------------------------------------------

User Types â†’ UserInput â†’ Two-Phase Validation â†’ Progress Calculation â†’ Visual Feedback

1. User types in native HTML input field (no wrapper components)
2. UserInput captures input and calls validateStepWithTwoPhase()
3. Two-Phase Validation Process:
   
   PHASE 1 - Mathematical Equivalence Check:
   - Uses isMathematicallyEquivalentRobust() for flexible math validation
   - Allows variations: "6*6+4" = "6(6)+4" = "6Ã—6+4" âœ…
   - Preserves mathematical flexibility for different notations
   
   PHASE 2 - Positional Validation Check:
   - Verifies answer is appropriate for current step position
   - Uses step label context ("substitution", "simplification", "final")
   - Prevents final answers in wrong positions
   - Enforces educational step-by-step learning approach

4. Progressive Percentage Calculation:
   - Step 1: 20% (substitution step - required, final answer blocked)
   - Step 2+: 80% (final answer allowed for quick completion)
   - All Steps: 100% (complete step-by-step solution)

5. Real-time UI Updates:
   - Progress bar with color-coded feedback
   - Step status indicators (âœ…âŒâš ï¸)
   - Dynamic messages based on validation state

TWO-PHASE VALIDATION SYSTEM DETAILS
----------------------------------

Core Validation Function: validateStepWithTwoPhase()

Input Parameters:
- userInput: string (what user typed)
- expectedAnswer: string (from answers.ts step.answer)
- stepLabel: string (from answers.ts step.label) 
- currentStepIndex: number (0-based position)
- allExpectedSteps: Step[] (complete step context)

Validation Logic:
```javascript
// Phase 1: Mathematical Flexibility
const mathematicallyCorrect = InputValidator.isMathematicallyEquivalentRobust(
  userInput.trim(), 
  expectedAnswer.trim()
);

// Phase 2: Position-Aware Logic
if (mathematicallyCorrect) {
  // RULE 1: If user got current step right, accept it
  isCurrentStepCorrect = true;
  
  // RULE 2: Check for final answer position enforcement
  if (userInputMatchesFinalAnswer && stepLabel !== "final") {
    if (currentStepIndex === 0) {
      // Block final answer in step 1 (must show substitution work)
      isCurrentStepCorrect = false;
    } else {
      // Allow final answer in step 2+ for 80% progression
      finalAnswerDetected = true;
      isCurrentStepCorrect = true;
    }
  }
}
```

Return Type: TwoPhaseValidationResult
- mathematicallyCorrect: boolean (Phase 1 result)
- positionallyValid: boolean (Phase 2 result)  
- finalAnswerDetected: boolean (Early final answer flag)
- isCurrentStepCorrect: boolean (Final validation decision)

USER EXPERIENCE IMPROVEMENTS
----------------------------

1. ENHANCED FOCUS MANAGEMENT:
   - Smart cursor positioning using requestAnimationFrame timing
   - Aggressive retry mechanism with focusLineAggressively()
   - Automatic cursor move to next line after Enter press
   - Timeout-based fallback for DOM update delays
   
   Focus Implementation:
   ```javascript
   const focusLineAggressively = (lineNumber: number, retryCount = 0) => {
     if (retryCount > 10) return; // Prevent infinite loops
     
     requestAnimationFrame(() => {
       const input = document.getElementById(`input-${lineNumber}`);
       if (input && input !== document.activeElement) {
         input.focus();
         setTimeout(() => focusLineAggressively(lineNumber, retryCount + 1), 50);
       }
     });
   };
   ```

2. STEP LIMIT RESTRICTIONS:
   - Input box creation restricted to required step count
   - canCreateNewLine() validates against expected steps length
   - Prevents users from creating infinite input fields
   - Maintains educational structure integrity
   
   Line Creation Logic:
   ```javascript
   const canCreateNewLine = () => {
     const maxLines = questionData?.steps?.length || 1;
     return lines.length < maxLines;
   };
   
   // In handleKeyDown:
   if (event.key === 'Enter' && canCreateNewLine()) {
     event.preventDefault();
     setLines(prev => [...prev, '']);
     focusLineAggressively(lines.length);
   }
   ```

3. INTELLIGENT INPUT HANDLING:
   - Prevents duplicate empty lines
   - Smart Enter key behavior based on step limits
   - Real-time validation feedback with visual cues
   - Responsive design for mobile and desktop

VALIDATION SYSTEM (UserInputValidator.tsx)
-----------------------------------------

Core Validation Methods (LEGACY - For Compatibility):
- validateAnswerArray(): Line-by-line array comparison
- validateAnswer(): Supports both string and array expected answers  
- getValidationResult(): Returns comprehensive validation state
- validateAllSteps(): Batch validation for multiple steps
- logValidation(): Enhanced console logging with array details

ACTIVE VALIDATION METHODS (Current System):
- isMathematicallyEquivalentRobust(): Advanced mathematical equivalence checking
  - Handles various mathematical notations and formats
  - Uses Math.js library for expression evaluation and comparison
  - Supports arithmetic, algebraic, and symbolic expressions
  - Core engine for Phase 1 mathematical validation

- validateStepWithTwoPhase(): NEW - Core validation function
  - Combines mathematical equivalence with positional validation
  - Returns comprehensive TwoPhaseValidationResult object
  - Handles final answer detection and position enforcement
  - Primary validation method used by UserInput component

Legacy Validation Process (Still Available):
1. Sanitizes user input array (removes whitespace, empty lines)
2. Compares directly against clean expected answer array
3. One-to-one line comparison: userInput[0] vs expectedAnswer[0]
4. Returns boolean result with detailed logging

Text Processing (Utility Methods):
- sanitizeText(): Removes whitespace, converts to lowercase
- sanitizeArray(): Sanitizes entire array of lines
- arrayToString(): Joins array with newlines (for compatibility)
- stringToArray(): Converts string to array (backward compatibility)

PROGRESSIVE PERCENTAGE SYSTEM & COMPLETION LOGIC
-----------------------------------------------

The new percentage calculation system provides intelligent progress tracking:

1. COMPLETION LOGIC:
   ```javascript
   const getCompletionStatus = () => {
     const status = { percentage: 0, message: "" };
     
     // Step 1 (20%): Must complete substitution step
     if (validationResults[0]?.isCurrentStepCorrect) {
       status.percentage = 20;
       status.message = "Great! Substitution step completed.";
     }
     
     // Steps 2+ (80%): Final answer detection OR step completion
     for (let i = 1; i < lines.length; i++) {
       if (validationResults[i]?.finalAnswerDetected || 
           validationResults[i]?.isCurrentStepCorrect) {
         status.percentage = 80;
         status.message = "Excellent! You found the final answer.";
         break;
       }
     }
     
     // All Steps (100%): Complete step-by-step solution
     const allStepsComplete = questionData?.steps?.every((_, index) => 
       validationResults[index]?.isCurrentStepCorrect
     );
     if (allStepsComplete) {
       status.percentage = 100;
       status.message = "Perfect! Complete solution achieved.";
     }
     
     return status;
   };
   ```

2. PERCENTAGE MILESTONES:
   - 0%: No correct answers yet
   - 20%: First step (substitution) completed - required baseline
   - 80%: Final answer detected in any step 2+ OR any step 2+ completed
   - 100%: All steps completed in proper sequence

3. VISUAL FEEDBACK:
   - Progress bar with smooth animations
   - Color-coded indicators (red â†’ yellow â†’ green)
   - Step-specific status messages
   - Real-time percentage updates

LEGACY VALIDATION FEATURES (For Reference)
-----------------------------------------

Enter Key Behavior:
- Press Enter â†’ Creates new line (if current line has content)
- Auto-focus moves to new line with proper cursor placement
- Maximum lines limited by expected steps count

Line Management:
- Backspace on empty line â†’ Deletes line and focuses previous
- Arrow Up/Down â†’ Navigate between lines
- Delete button (hover) â†’ Remove specific lines
- Add line button â†’ Manual line creation

Data Storage:
- Each step stores lines as string[] array
- Individual lines accessible as separate elements
- Format: userInputs[stepIndex][lineIndex] = "line content"

Line-by-Line Validation:
- User: ["  2x + 3  ", " = 7 ", "x = 2"]
- Sanitized: ["2x+3", "=7", "x=2"]
- Expected: ["2x+3", "=7", "x=2"] (from answers.ts)
- Result: âœ… All lines match

Enhanced Validation Features:
- Length validation (arrays must have same number of lines)
- Empty line filtering
- Detailed mismatch reporting
- Support for step-by-step mathematical solutions
- Console clearing to prevent log spam

UPDATED VALIDATION EXAMPLES (Two-Phase System)
----------------------------------------------

Example 1 - Proper Step Progression:
Problem: Evaluate 6*6+4
User Input Line 1: "6(6)+4"    â†’ âœ… Matches substitution step
User Input Line 2: "36 + 4"    â†’ âœ… Matches simplification step  
User Input Line 3: "40"        â†’ âœ… Matches final answer
Result: 100% completion - Perfect step-by-step solution

Example 2 - Final Answer Detection:
Problem: Evaluate 6*6+4
User Input Line 1: "6(6)+4"    â†’ âœ… Matches substitution step (20%)
User Input Line 2: "40"        â†’ âœ… Final answer detected (80% total)
Result: 80% completion - Skipped intermediate step but found final answer

Example 3 - Position Enforcement:
Problem: Evaluate 6*6+4  
User Input Line 1: "40"        â†’ âŒ Final answer blocked in step 1
Result: 0% completion - Must show substitution work first

Example 4 - Mathematical Equivalence:
Problem: Evaluate 6*6+4
User Input: "6Ã—6+4"            â†’ âœ… Equivalent to "6*6+4" (different notation)
User Input: "6(6)+4"           â†’ âœ… Equivalent to "6*6+4" (parentheses notation)
Result: Mathematical flexibility preserved while enforcing position rules

LEGACY VALIDATION EXAMPLES (For Reference)
-------------------

Example 1 - Function Evaluation:
User Input: ["g(7) = 7 + 5", "g(7) = 12"]
Expected:   ["g(7) = 7 + 5", "g(7) = 12"]
Result: âœ… Perfect match

Example 2 - Complex Calculation:
User Input: ["f(-2) = 2(-2)Â² - 3(-2) + 1", "f(-2) = 8 + 6 + 1", "f(-2) = 15"]
Expected:   ["f(-2) = 2(-2)Â² - 3(-2) + 1", "f(-2) = 2(4) + 6 + 1", "f(-2) = 8 + 6 + 1", "f(-2) = 15"]
Result: âŒ Line 2 mismatch and missing step

Example 3 - Length Mismatch:
User Input: ["Yes"]
Expected:   ["Yes", "Each x-value maps to only one y-value"]
Result: âŒ Length mismatch: 1 vs 2 lines

UPDATED USAGE EXAMPLE (Two-Phase System)
----------------------------------------

// New UserInput component usage with two-phase validation:
<UserInput
  questionData={{
    steps: [
      { label: "substitution", answer: "6(6)+4" },
      { label: "simplification", answer: "36 + 4" },
      { label: "final", answer: "40" }
    ]
  }}
  onChange={(lines, completionStatus) => {
    console.log('Input lines:', lines);
    console.log('Progress:', completionStatus.percentage + '%');
    console.log('Message:', completionStatus.message);
  }}
/>

// Two-phase validation usage:
const result = InputValidator.validateStepWithTwoPhase(
  "40",                    // User input
  "6(6)+4",               // Expected answer for current step
  "substitution",         // Step label
  0,                      // Current step index
  allSteps                // All expected steps for context
);

console.log('Mathematical:', result.mathematicallyCorrect);    // May be true
console.log('Positional:', result.positionallyValid);         // May be false  
console.log('Final Decision:', result.isCurrentStepCorrect);   // Final result
console.log('Final Answer:', result.finalAnswerDetected);     // Early completion flag

LEGACY USAGE EXAMPLE (For Reference)
-------------

// Parent component usage:
<AnswerWizard
  expectedAnswers={getAnswerForQuestion(2, 1, 1)}  // From answers.ts
  onLinesChange={(stepIndex, lines) => {
    console.log(`Step ${stepIndex} lines:`, lines);
    // lines = ["g(7) = 7 + 5", "g(7) = 12"]
  }}
  onSubmit={(steps, result) => {
    // UserInputValidator handles all validation logic
    console.log('Validation result:', result);
  }}
/>

// Direct validator usage:
const isValid = InputValidator.validateAnswer(
  ["2x+3", "=7", "x=2"],           // User input
  ["2x+3", "=7", "x=2"],           // Expected from answers.ts
  0                                 // Step index
);

UPDATED CONSOLE OUTPUT (Two-Phase System)
-----------------------------------------

Two-Phase Validation Console Output:
```
ğŸ” TWO-PHASE VALIDATION - Step 0
ğŸ‘¤ User Input: "40"
ğŸ“‹ Expected: "6(6)+4" (label: substitution)
ğŸ§® Phase 1 - Mathematical Check: âŒ (40 â‰  6(6)+4)
ğŸ¯ Phase 2 - Position Check: N/A (Phase 1 failed)
ğŸ” Final Answer Check: âœ… (40 matches final answer)
ğŸš« Position Enforcement: BLOCKED (final answer in step 1)
ğŸ“Š Result: âŒ Step incorrect
ğŸ“ˆ Progress: 0%
```

```  
ğŸ” TWO-PHASE VALIDATION - Step 1
ğŸ‘¤ User Input: "40"
ğŸ“‹ Expected: "36 + 4" (label: simplification)
ğŸ§® Phase 1 - Mathematical Check: âŒ (40 â‰  36 + 4)
ğŸ¯ Phase 2 - Position Check: N/A (Phase 1 failed)
ğŸ” Final Answer Check: âœ… (40 matches final answer)
ğŸ‰ Final Answer Detection: ALLOWED (step 1+)
ğŸ“Š Result: âœ… Final answer detected!
ğŸ“ˆ Progress: 80%
```

Progress Status Console:
```
ğŸ“Š COMPLETION STATUS UPDATE
ğŸ“ˆ Current Progress: 80%
ğŸ’¬ Status Message: "Excellent! You found the final answer."
ğŸ¯ Step 1 Status: âœ… (Final answer detected)
ğŸ”¢ Lines Completed: 1/3
â±ï¸  Validation Time: 2.3ms
```

LEGACY CONSOLE OUTPUT (For Reference)
------------------------------------

Legacy Validation Console (with console.clear()):
=== INPUT VALIDATION ===
Step Index: 0
User Input Array: ["g(7) = 7 + 5", "g(7) = 12"]
Individual lines: ["Line 1: g(7) = 7 + 5", "Line 2: g(7) = 12"]  
Expected Answer Array: ["g(7) = 7 + 5", "g(7) = 12"]
Expected lines: ["Line 1: g(7) = 7 + 5", "Line 2: g(7) = 12"]
Sanitized User Array: ["g(7)=7+5", "g(7)=12"]
Is Valid: true
========================

Array Validation Details:
=== ARRAY VALIDATION ===
User Array (sanitized): ["g(7)=7+5", "g(7)=12"]
Expected Array (clean): ["g(7)=7+5", "g(7)=12"]
âœ… All lines match!

DATA STRUCTURE
--------------

answers.ts Structure:
answersByTopicAndCategory = {
  1: { // Introduction to Functions
    1: [
      { type: "multiLine", answer: ["No", "The x-value 2 maps to both 3 and 5"] },
      { type: "multiLine", answer: ["Yes", "Each x-value maps to only one y-value"] }
    ]
  },
  2: { // Evaluating Functions
    1: [
      { type: "multiLine", answer: ["g(7) = 7 + 5", "g(7) = 12"] }
    ]
  }
}

userInputs Storage:
userInputs = [
  ["g(7) = 7 + 5", "g(7) = 12"],                    // Step 0
  ["p(6) = 6Â² + 4", "p(6) = 36 + 4", "p(6) = 40"], // Step 1  
  ["f(-2) = 2(-2)Â² - 3(-2) + 1", "f(-2) = 15"]     // Step 2
]

Access pattern:
- userInputs[0][0] = "g(7) = 7 + 5"
- userInputs[0][1] = "g(7) = 12"
- getAnswerForQuestion(2, 1, 1) = ["g(7) = 7 + 5", "g(7) = 12"]

VALIDATION FLOW
---------------

1. User completes lines in UserInput
2. AnswerWizard calls UserInputValidator.logValidation()
3. UserInputValidator.validateAnswer() performs line-by-line comparison
4. Expected answer retrieved from answers.ts via getAnswerForQuestion()
5. Sanitized user input compared against clean expected answer
6. Detailed validation results logged to console
7. UI updated with validation state (correct/wrong/pending)

ERROR HANDLING
--------------

- Spam Detection: Prevents rapid character input bursts
- Empty Line Prevention: Can't create new lines without content
- Max Lines Limit: Enforced 8-line maximum per question
- Ref Management: Proper focus handling with forwardRef pattern
- Length Validation: Arrays must have matching number of lines
- Line-by-Line Mismatch: Detailed reporting of which lines don't match
- Console Management: Auto-clearing prevents log accumulation

DEVELOPMENT NOTES
-----------------

- Enhanced console logging with array-specific details
- TypeScript interfaces ensure type safety across components
- Responsive design with mobile keyboard support
- Accessible navigation with keyboard shortcuts
- Line-by-line validation optimized for mathematical step-by-step solutions
- Expected answers pre-formatted in answers.ts (no sanitization needed)
- Backward compatibility maintained for string-based expected answers
- UserInputValidator separated for reusability